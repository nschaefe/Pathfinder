it could be useful to have a no-false-positives and a no-false-negative mode
 --> no-false-positives only gives sensible boundaries that need to be supported, but could miss some cases
     no-false-negatives is the other way round, complete but much
 no-false-positives:  do not support array as fields (stretching),
                      do not consider writes of newly created objects in constructors (init cases)

support field access if the object is an array. that gives a false positive everytime the array
 is streched, but this could lead to false negatives (rare) -> later: we should have an option to
 switch it on

reading and writing an object to another array index or another array (copied), does
 not loose old writers, if we associate writers with an object.
 but we have to recognize positions when a writer overtake is sensible. We do not want to overtake everytime or aggregate all writers.
 If the copier writes the object, it will take the place of the old writer
 We have to identify when a array is copied and the write is just because of the copy.
 because e.g. load balancing of requests over workers gives false positives, if we overtake when we copy to another array every time.
 So only if we copy an array that ends up being in the same location as the old one, but this is not trivial to detect.
 -> for now it is ok to rely on the nondeterminism argument when arrays are copied.
 easy way for refactoring to object perspective-> We currently look at accesses to ArrayFields or Fields (represent locations) and track accesses to them
 we just have to redefine what an access location is. Instead of fields and arrays we say objects if we have
 an object at hand or the field location (array index, field) if it is a primitive.

support for fields with other types than object e.g. for array as field (access of the array object)

REFACTOR: Facade that delegates to controller that delegates to backend
  field access meta as pure datastructure/infrastructure, move logic
performance: allow more interleaving, task related things can run under a different lock, comes with refactoring
refactor inits
move task logic to other class
